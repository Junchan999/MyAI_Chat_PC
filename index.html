<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ｍｙチャット履歴</title>
    <style>
        html {
            height: 100%;
        }
        body {
            height: 100vh; /* 画面の高さに合わせる */
            margin: 0;
            font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            background: linear-gradient(to bottom, #e0fff0, #ffffff);
            display: flex;
            flex-direction: column;
            overflow: hidden; /* bodyのスクロールを禁止 */
        }
        header {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            flex-wrap: nowrap;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: sticky;
            top: 0;
            z-index: 100;
            flex-shrink: 0;
        }
        header h1 {
            margin: 0;
            font-size: 1.5em;
            color: #2e8b57;
            font-weight: bold;
            white-space: nowrap;
        }
        .header-controls {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        .header-buttons {
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            gap: 10px;
        }
        .header-buttons button {
            padding: 8px 15px;
            border: none;
            /* background-color: #4CAF50; */ /* 各ボタンで個別に設定するため、ここではデフォルトの背景色にしない */
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        .header-buttons button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        /* ヘッダーボタンのデフォルト色 */
        #persona-button,
        #load-chat-history-button,
        #new-chat-button,
        #settings-button,
        #help-button {
            background-color: #ffffff;
            color: #555;
            border: 1px solid #ddd;
        }
        /* 各ヘッダーボタンの個別スタイル */
        #delete-selected-button { background-color: #f44336; }
        #edit-selected-button { background-color: #ff9800; }
        #save-chat-summary-button { background-color: #3cb371; } /* チャット保存ボタンの正しいスタイル */
        #print-pdf-button { background-color: #007bff; } /* PDF印刷ボタンのスタイル */


        .main-container {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 20px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            flex-grow: 1;
            overflow: hidden;
        }

        /* サイドパネル（タイマーと入力欄） */
        #side-panel {
            width: 280px;
            min-width: 280px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #side-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            color: #2e8b57;
        }
        .timer-control {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }
        .timer-control input[type="number"] {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #ddd;
            text-align: center;
            box-sizing: border-box;
        }
        .timer-control button {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            color: white;
            cursor: pointer;
        }
        #timer-start-button { background-color: #3cb371; }
        #timer-stop-button { background-color: #f08080; }
        #timer-display {
            font-weight: bold;
            color: #2e8b57;
            min-height: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .chat-container {
            width: 100%;
            max-width: 600px;
            flex-grow: 1;
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        #datetime-display {
            text-align: center;
            padding: 8px;
            background-color: rgba(240, 240, 240, 0.7);
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            font-size: 1.2em; /* 少し小さめに調整 */
            color: #555;
            flex-shrink: 0;
        }
        .chat-box {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .message {
            margin-bottom: 12px;
            padding: 10px 15px;
            border-radius: 20px;
            max-width: 80%;
            line-height: 1.5;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .message.selected { background-color: #ffebee; border: 1px solid #e57373; }
        .message img.message-image { max-width: 100%; border-radius: 10px; margin-bottom: 8px; }
        .user-message { background-color: #c8e6c9; align-self: flex-end; margin-left: auto; border-bottom-right-radius: 5px; }
        .bot-message { background-color: #ffffff; align-self: flex-start; border-bottom-left-radius: 5px; }
        .error-message { background-color: #f8d7da; color: #721c24; align-self: flex-start; }
        .summary-message { background-color: #fef9e7; align-self: center; width: 95%; max-width: 95%; border: 1px solid #fceecb; text-align: left; }
        .timestamp { font-size: 0.75em; color: #888; margin-top: 4px; }
        
        .input-area {
            display: flex;
            flex-direction: column;
            padding-top: 10px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            flex-grow: 1;
            min-height: 0;
        }
        #image-preview-container {
            position: relative;
            margin-bottom: 8px;
            display: none;
            width: fit-content;
        }
        #image-preview { max-width: 100px; max-height: 100px; border-radius: 8px; border: 1px solid #ddd; }
        #remove-image-button {
            position: absolute; top: -5px; right: -5px; width: 20px; height: 20px;
            border-radius: 50%; border: none; background-color: rgba(0, 0, 0, 0.6);
            color: white; cursor: pointer; font-size: 14px; line-height: 20px; text-align: center;
        }
        
        .input-controls { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; }
        .input-buttons-container { display: flex; gap: 10px; margin-bottom: 8px; flex-wrap: wrap;} /* wrapを追加 */
        #text-input {
            flex-grow: 1; width: 100%; box-sizing: border-box; border: 1px solid #ddd;
            border-radius: 12px; padding: 10px 15px; resize: vertical;
            font-family: inherit; font-size: 1em;
        }
        #text-input:focus {
            outline: none; border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
        }

        /* 入力欄のアイコンボタンのスタイル (円形) */
        #file-input-button, #mic-button, #send-button {
            width: 40px; height: 40px; border-radius: 50%; border: none; color: white;
            cursor: pointer; flex-shrink: 0; font-size: 1.5em; line-height: 40px; text-align: center;
            display: inline-flex; justify-content: center; align-items: center; transition: background-color 0.3s;
            padding: 0;
        }
        #file-input-button { background-color: #81c784; }
        #mic-button { background-color: #66cdaa; }
        #mic-button.recording { background-color: #f08080; }
        #send-button { background-color: #2196F3; }

        /* 絵文字ボタンコンテナ */
        .emoji-buttons-container {
            display: flex;
            flex-wrap: wrap; /* ボタンが多いため折り返す */
            gap: 5px; /* ボタン間のスペース */
            margin-bottom: 8px;
        }
        .emoji-button {
            width: 38px; /* 少し小さめに調整 */
            height: 38px; /* 少し小さめに調整 */
            border-radius: 50%;
            border: 1px solid #ddd; /* ボーダーを追加 */
            background-color: #f8f8f8; /* 薄い背景色 */
            color: #333; /* 文字色 */
            cursor: pointer;
            font-size: 1.2em; /* 絵文字サイズ */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .emoji-button:hover {
            background-color: #e0e0e0;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }


        /* モーダル共通スタイル */
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); }
        .modal-content {
            background-color: #fefefe; margin: 2.5vh auto; padding: 20px; border: 1px solid #888;
            width: 90%; max-width: 800px; /* 表示幅を広げました */
            border-radius: 8px; display: flex; flex-direction: column;
            max-height: 95vh;
        }
        #settings-modal .modal-content { max-width: 500px; }
        .modal-body { overflow-y: auto; padding-right: 10px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .modal-content h2 { margin-top: 0; flex-shrink: 0; }
        .modal-content h3 { font-size: 1.1em; margin-top: 20px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .name-setting-container { display: flex; gap: 10px; align-items: center; }
        .name-setting-container label { flex-basis: 100px; }
        .name-setting-container input { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        
        #persona-textarea, #auto-response-prompt-textarea, #summary-prompt-textarea, #api-key-input {
            width: 100%; margin-top: 10px; box-sizing: border-box; border-radius: 4px;
            border: 1px solid #ccc; padding: 8px; font-family: inherit;
        }
        #persona-textarea { height: 200px; resize: vertical; }
        #auto-response-prompt-textarea { height: 100px; resize: vertical; }
        #summary-prompt-textarea { height: 150px; resize: vertical; } /* 新しい textarea の高さ */
        #api-key-input { height: auto; }

        .examples-container { margin-top: 10px; }
        .examples-container button { margin-right: 5px; margin-bottom: 5px; }
        .modal-buttons { display: flex; justify-content: space-between; align-items: center; margin-top: auto; padding-top: 20px; flex-shrink: 0; }
        .settings-columns { display: flex; gap: 25px; }
        .settings-column { flex: 1; }
        @media (max-width: 768px) {
            .settings-columns { flex-direction: column; gap: 10px; }
        }

        /* チャット履歴リスト表示用 */
        #chat-history-list-modal .modal-content { max-width: 900px; } /* 表示幅を広げました */
        #chat-history-search-input {
            width: calc(100% - 20px);
            padding: 10px;
            margin: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
        }
        #chat-history-list {
            list-style: none;
            padding: 0;
            margin: 0 10px; /* 検索入力欄と揃えるため */
            border: 1px solid #eee;
            border-radius: 5px;
            overflow-y: auto;
            max-height: 60vh; /* 検索入力欄やボタンのスペースを考慮 */
            margin-bottom: 10px;
        }
        #chat-history-list li {
            padding: 12px 10px; /* チェックボックスのスペース確保 */
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center; /* 垂直方向中央揃え */
        }
        #chat-history-list li:last-child { border-bottom: none; }
        #chat-history-list li:hover { background-color: #e8f5e9; }
        #chat-history-list li .history-item-content {
            flex-grow: 1;
            margin-left: 10px; /* チェックボックスとの間隔 */
        }
        #chat-history-list li .title { font-weight: bold; color: #333; }
        #chat-history-list li .date-time { font-size: 0.8em; color: #666; margin-top: 4px; }


        .chat-history-list-footer { /* 新しいボタンを配置するフッター */
            display: flex;
            justify-content: space-between; /* 左右に配置 */
            align-items: center;
            padding: 10px;
            border-top: 1px solid #eee;
            flex-wrap: wrap; /* ボタンが多い場合に折り返す */
            gap: 10px; /* ボタン間のスペース */
        }
        .chat-history-list-footer .left-buttons,
        .chat-history-list-footer .right-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: nowrap;
        }

        /* 並べ替えコントロールのスタイル */
        .sort-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: nowrap; /* 折り返さない */
        }
        .sort-controls label {
            white-space: nowrap; /* テキストの折り返しを防ぐ */
            margin-right: 5px;
        }
        .sort-controls select {
            padding: 6px 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
            font-size: 0.9em;
        }
        .sort-controls button {
            background-color: #6c757d;
            color: white;
            padding: 6px 10px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s ease;
        }
        .sort-controls button:hover {
            background-color: #5a6268;
        }
        .sort-order-icon {
            font-size: 1.1em;
            vertical-align: middle;
        }


        /* ボタンの配置順序をCSSで調整 */
        /* #load-selected-history-button { order: -1; } */ /* JSで直接ボタンを生成するため、CSSでのorderは不要に */


        /* CSVエクスポート/インポートボタンのスタイル */
        .csv-buttons-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            align-items: center;
        }
        .csv-buttons-container button, .csv-buttons-container label {
            padding: 8px 15px;
            border: none;
            background-color: #607d8b; /* CSVボタン用の色 */
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            white-space: nowrap;
        }
        .csv-buttons-container button:hover, .csv-buttons-container label:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        #import-csv-input, #import-all-history-input { /* ファイル入力要素を隠し、ラベルで代用 */
            display: none;
        }

        @media (max-width: 1250px) { /* 3カラムを維持するブレークポイントを調整 */
            .main-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
                padding: 10px;
                overflow-y: auto;
            }
            #side-panel {
                order: -2; /* 入力欄を一番上に */
                width: 100%;
                max-width: 600px;
                margin-bottom: 10px;
            }
            .header-controls { justify-content: flex-end; }
            header h1 { font-size: 1.2em; }
        }

        /* 印刷時のスタイル */
        @media print {
            body { margin: 0; padding: 0; }
            header, #side-panel, .input-area, .modal, .chat-history-list-footer { display: none !important; }
            .main-container {
                display: block; /* print時にはflexbox解除 */
                padding: 0;
                margin: 0;
            }
            .chat-container { 
                border: none; 
                box-shadow: none; 
                max-width: none; 
                width: 100%; 
                background-color: #fff;
                backdrop-filter: none;
                overflow: visible; /* 印刷時にスクロールさせない */
            }
            #datetime-display { display: none; } /* 印刷時には日付・時刻表示を非表示にするか、別途スタイル調整 */
            .chat-box { 
                overflow: visible; /* 印刷時にスクロールさせない */
                padding: 10px;
            }
            /* メッセージの途中で改ページしない設定 */
            .message, .chat-log .message { 
                box-shadow: none; 
                border: 1px solid #eee;
                margin-bottom: 5px; /* 余白を詰める */
                padding: 8px 12px; 
                border-radius: 8px; 
                max-width: 100%; 
                word-wrap: break-word; 
                page-break-inside: avoid; /* ここに改ページ抑制を追加 */
            }
            .user-message { background-color: #e0f0e0; text-align: right; margin-left: auto; border-bottom-right-radius: 5px;} /* PDF印刷用に調整 */
            .bot-message { background-color: #f0f0f0; text-align: left; border-bottom-left-radius: 5px;} /* PDF印刷用に調整 */
            .chat-log .speaker { font-weight: bold; margin-bottom: 0px; display: block; } /* 余白を詰める */
            .chat-log .timestamp { font-size: 0.75em; color: #666; margin-top: 2px; display: block; text-align: right;} /* 余白を詰める */
            .message-content { margin-top: 2px; } /* メッセージ本体と発言者・時刻の間に少し余白 */
            
            .summary-message { background-color: #fff8e6; border: 1px solid #ffeeba; text-align: left; margin: 10px 0; } /* PDF印刷用に調整 */
            .summary-message h3 { font-size: 1.1em; margin-top: 0; margin-bottom: 5px; border-bottom: none; }
            .summary-message h2 { font-size: 1.4em; margin-top: 10px; margin-bottom: 5px; border-bottom: none; }
            .summary-message p { margin-top: 5px; margin-bottom: 0; }
            
            h1, h2, h3 { color: #2e8b57; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-top: 15px; margin-bottom: 10px; }
            hr { border: 0; border-top: 1px dashed #ccc; margin: 15px 0; }
            .message-image { max-width: 80%; height: auto; border-radius: 5px; margin-top: 5px; display: block; margin-left: auto; margin-right: auto; } /* 中央寄せ */
            .chat-log { padding: 10px 0; } /* 履歴部分のパディング */
        }
    </style>
</head>
<body>

<header>
    <h1>Ｍｙチャット履歴 Ver1.06</h1>
    <div class="header-controls">
        <div class="header-buttons">
            <button id="persona-button">各種設定</button>
            <button id="delete-selected-button" style="display: none; background-color: #f44336;">選択を削除</button>
            <button id="edit-selected-button" style="display: none; background-color: #ff9800;">選択を編集</button>
            <button id="save-chat-summary-button">チャット保存</button>
            <button id="load-chat-history-button">履歴一覧</button>
            <button id="print-pdf-button" style="display: none;">PDFプレビュー</button> <!-- PDF印刷ボタンをPDFプレビューに変更 -->
            <button id="new-chat-button">新しいチャット</button>
            <button id="settings-button">API設定</button>
            <button id="help-button">取扱説明書</button>
        </div>
    </div>
</header>

<input type="file" id="chat-file-input" style="display: none;" accept=".md,.txt">
<input type="file" id="image-file-input" style="display: none;" accept="image/*">
<!-- CSVインポート用ファイル入力 -->
<input type="file" id="import-csv-input" style="display: none;" accept=".csv">
<!-- 全チャット履歴エクスポート/インポート用ファイル入力 -->
<input type="file" id="import-all-history-input" style="display: none;" accept=".json">


<div class="main-container">
    <div class="chat-container">
        <div id="datetime-display"></div>
        <div class="chat-box" id="chat-box"></div>
    </div>
    
    <!-- サイドパネル（タイマーと入力欄） -->
    <div id="side-panel">
        <div>
            <h3>自動応答タイマー</h3>
            <div class="timer-control">
                <input type="number" id="timer-input" placeholder="分単位で入力" min="1">
                <button id="timer-start-button">開始</button>
                <button id="timer-stop-button" style="display: none;">停止</button>
                <div id="timer-display"></div>
            </div>
        </div>
        
        <div class="input-area">
            <div id="image-preview-container">
                <img id="image-preview" src="" alt="Image Preview">
                <button id="remove-image-button">&times;</button>
            </div>
            <div class="input-controls">
                <!-- 絵文字ボタンコンテナを追加 -->
                <div class="emoji-buttons-container" id="emoji-buttons-container">
                    <button type="button" class="emoji-button" data-emoji="😊"></button>
                    <button type="button" class="emoji-button" data-emoji="😂"></button>
                    <button type="button" class="emoji-button" data-emoji="💖"></button>
                    <button type="button" class="emoji-button" data-emoji="✨"></button>
                    <button type="button" class="emoji-button" data-emoji="👍"></button>
                    <button type="button" class="emoji-button" data-emoji="🤔"></button>
                    <button type="button" class="emoji-button" data-emoji="🎉"></button>
                    <button type="button" class="emoji-button" data-emoji="🙏"></button>
                    <button type="button" class="emoji-button" data-emoji="🌟"></button>
                    <button type="button" class="emoji-button" data-emoji="💡"></button>
                </div>
                <div class="input-buttons-container">
                    <button id="file-input-button" title="画像を選択">📎</button>
                    <button id="mic-button" title="音声入力">🎤</button>
                    <button id="send-button" title="メッセージを送信">✈️</button>
                </div>
                <textarea id="text-input" placeholder="メッセージを入力または画像をペースト... (Shift+Enterで改行)"></textarea>
            </div>
        </div>
    </div>
</div>

<!-- 各種設定モーダル -->
<div id="persona-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="close-persona-modal">&times;</span>
        <h2>各種設定</h2>
        <!-- 全チャット履歴のエクスポート/インポート機能を最上部に移動 -->
        <h3 style="margin-top:0;">全チャット履歴のエクスポート/インポート</h3>
        <div class="csv-buttons-container">
            <button id="export-all-history-button" style="background-color: #4CAF50;">全履歴をJSONで保存</button>
            <label for="import-all-history-input" style="background-color: #607d8b;">全履歴をJSONから読込</label>
        </div>
        <hr style="margin-top:20px; border-top:1px dashed #eee;">

        <div class="modal-body">
            <div class="settings-columns">
                <div class="settings-column"> <!-- 左カラム -->
                    <h3>AIの性格（システムプロンプト）</h3>
                    <p>AIの振る舞いを指定する指示を入力してください。</p>
                    <textarea id="persona-textarea" placeholder="例：あなたは親切でフレンドリーなアシスタントです。絵文字をたくさん使って、ユーザーを励ましてください。"></textarea>
                    <div class="examples-container">
                        <p>設定例:</p>
                        <button class="persona-example-btn" data-persona="あなたはユーザーをサポートする、親切で優しいアシスタントです。常に丁寧な言葉遣いを心がけてください。">優しいアシスタント</button>
                        <button class="persona-example-btn" data-persona="あなたは特定の分野の専門家です。質問に対して、専門用語を交えつつ、常に簡潔かつ正確に答えてください。">簡潔な専門家</button>
                        <button class="persona-example-btn" data-persona="あんたは関西弁を話す、気さくな友達やで。タメ口で、たまに冗談を交えながら返事してな。">関西弁の友達</button>
                    </div>
                </div>
                <div class="settings-column"> <!-- 右カラム -->
                    <h3>自動応答プロンプト</h3>
                    <p>タイマー応答時のAIへの指示です。</p>
                    <textarea id="auto-response-prompt-textarea" placeholder="例：時間になりました。自然な会話の流れで、何か新しい話題を提供したり、私に質問をしてみてください。"></textarea>

                    <h3>チャット概要生成プロンプト</h3>
                    <p>チャット保存時の概要生成AIへの指示です。<br><code>{CONVERSATION_HISTORY}</code>に会話履歴が挿入されます。</p>
                    <textarea id="summary-prompt-textarea" placeholder="例：以下の会話履歴を基に、簡潔なタイトル（30文字程度）と、会話の要約を箇条書きにして作成し、JSON形式で出力してください。\n\n出力は以下のJSONフォーマットに従ってください。\n{\n  &quot;title&quot;: &quot;ここにタイトルを記述 (15文字程度)&quot;,\n  &quot;summary&quot;: &quot;ここに会話の要約を記述 (第三者の視点から自然な文章で)&quot;\n}\n\n---\n[会話履歴]\n{CONVERSATION_HISTORY}\n---"></textarea>

                    <h3>会話履歴の名前設定</h3>
                    <div class="name-setting-container" style="margin-bottom: 10px;">
                        <label for="user-name-input">あなたの名前:</label>
                        <input type="text" id="user-name-input" placeholder="ユーザー">
                    </div>
                    <div class="name-setting-container">
                        <label for="ai-name-input">AIの名前:</label>
                        <input type="text" id="ai-name-input" placeholder="AI">
                    </div>

                    <h3>サウンド設定</h3>
                    <div class="sound-settings">
                        <div>
                            <input type="checkbox" id="sound-on-off" checked>
                            <label for="sound-on-off">AI応答時にサウンドを鳴らす</label>
                        </div>
                        <div>
                            <label for="sound-type-select">サウンドの種類:</label>
                            <select id="sound-type-select">
                                <option value="sine">サイン波 (標準)</option>
                                <option value="square">矩形波 (ピコピコ)</option>
                                <option value="sawtooth">のこぎり波 (ブザー)</option>
                                <option value="triangle">三角波 (マイルド)</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="csv-buttons-container">
                <button id="export-csv-button">設定をCSVで保存</button>
                <label for="import-csv-input" id="import-csv-button">設定をCSVから読込</label>
            </div>
        </div>
        <div class="modal-buttons">
            <div></div>
            <div class="right-buttons">
                 <button id="save-settings-button">保存</button>
            </div>
        </div>
    </div>
</div>

<!-- APIキー設定モーダル -->
<div id="settings-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="close-settings-modal">&times;</span>
        <h2>Gemini APIキー設定</h2>
        <div class="modal-body">
            <p>ここに取得したGemini APIキーを入力して保存してください。</p>
            <input type="password" id="api-key-input" placeholder="APIキーを入力...">
            <div id="test-key-result"></div>
        </div>
        <div class="modal-buttons">
            <button id="delete-key-button">キーを削除</button>
            <div class="right-buttons">
                <button id="test-key-button">APIキーをテスト</button>
                <button id="save-key-button">保存</button>
            </div>
        </div>
    </div>
</div>

<!-- メッセージ編集モーダル -->
<div id="edit-message-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="close-edit-message-modal">&times;</span>
        <h2>メッセージの編集</h2>
        <div class="modal-body">
            <textarea id="edit-message-textarea" style="width: 100%; height: 150px; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; resize: vertical;"></textarea>
            <button id="save-edited-message-button" style="background-color: #4CAF50; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">保存</button>
        </div>
    </div>
</div>

<!-- チャット履歴リストモーダル -->
<div id="chat-history-list-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" id="close-chat-history-list-modal">&times;</span>
        <h2>チャット履歴一覧</h2>
        <input type="text" id="chat-history-search-input" placeholder="タイトルや日付で検索...">
        <ul id="chat-history-list">
            <!-- チャット履歴がここに表示されます -->
        </ul>
        <div class="chat-history-list-footer">
            <div class="left-buttons">
                <button id="select-all-history-button" style="background-color: #007bff;">全選択</button>
                <button id="deselect-all-history-button" style="background-color: #6c757d;">全解除</button>
                <button id="load-selected-history-button" style="background-color: #28a745;">選択を読込</button> <!-- 左側に移動 -->
            </div>
            <div class="sort-controls"> <!-- 新しい並べ替えコントロール -->
                <label for="sort-by-select">並べ替え:</label>
                <select id="sort-by-select" style="padding: 6px; border-radius: 5px; border: 1px solid #ccc;">
                    <option value="date">日付</option>
                    <option value="title">タイトル</option>
                </select>
                <button id="sort-order-button" style="background-color: #6c757d; color: white; padding: 6px 10px; border-radius: 5px; border: none; margin-left: 5px;">
                    <span id="sort-order-icon" class="sort-order-icon">↓</span>
                </button>
            </div>
            <div class="right-buttons">
                <button id="delete-selected-history-button" style="background-color: #dc3545;">選択を削除</button>
            </div>
        </div>
    </div>
</div>

<!-- PDF Viewer Modal -->
<div id="pdf-viewer-modal" class="modal">
    <div class="modal-content" style="max-width: 90%; height: 90vh;">
        <span class="close-button" id="close-pdf-viewer-modal">&times;</span>
        <h2>PDFプレビュー</h2>
        <div class="modal-body" style="flex-grow: 1; display: flex; flex-direction: column;">
            <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">
                <strong>💡ご注意:</strong> 正しいファイル名でダウンロードするには、下の「PDFをダウンロード」ボタンを使用してください。<br>
                ブラウザのPDFビューアが提供するダウンロードボタンでは、ファイル名が意図しないものになる場合があります。
            </p>
            <iframe id="pdf-frame" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
        <div class="modal-buttons">
            <button id="download-pdf-button" style="background-color: #007bff; color: white; padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">PDFをダウンロード</button>
        </div>
    </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script>
    // DOM要素の取得
    const chatBox = document.getElementById('chat-box');
    const textInput = document.getElementById('text-input');
    const sendButton = document.getElementById('send-button');
    const micButton = document.getElementById('mic-button');
    const saveChatSummaryButton = document.getElementById('save-chat-summary-button');
    const loadChatHistoryButton = document.getElementById('load-chat-history-button');
    const printPdfButton = document.getElementById('print-pdf-button'); // PDF印刷ボタン
    const newChatButton = document.getElementById('new-chat-button');
    const helpButton = document.getElementById('help-button');
    const datetimeDisplay = document.getElementById('datetime-display');
    const imageFileInput = document.getElementById('image-file-input');
    const fileInputButton = document.getElementById('file-input-button');
    const imagePreviewContainer = document.getElementById('image-preview-container');
    const imagePreview = document.getElementById('image-preview');
    const removeImageButton = document.getElementById('remove-image-button');
    const userNameInput = document.getElementById('user-name-input');
    const aiNameInput = document.getElementById('ai-name-input'); 
    const timerInput = document.getElementById('timer-input');
    const timerStartButton = document.getElementById('timer-start-button');
    const timerStopButton = document.getElementById('timer-stop-button');
    const timerDisplay = document.getElementById('timer-display');
    const deleteSelectedButton = document.getElementById('delete-selected-button');
    const editSelectedButton = document.getElementById('edit-selected-button');

    // モーダル関連のDOM要素
    const personaButton = document.getElementById('persona-button');
    const personaModal = document.getElementById('persona-modal');
    const closePersonaModal = document.getElementById('close-persona-modal');
    const personaTextarea = document.getElementById('persona-textarea');
    const saveSettingsButton = document.getElementById('save-settings-button');
    const personaExampleBtns = document.querySelectorAll('.persona-example-btn');
    const settingsButton = document.getElementById('settings-button');
    const settingsModal = document.getElementById('settings-modal');
    const closeSettingsModal = document.getElementById('close-settings-modal');
    const apiKeyInput = document.getElementById('api-key-input');
    const saveKeyButton = document.getElementById('save-key-button');
    const soundOnOff = document.getElementById('sound-on-off');
    const soundTypeSelect = document.getElementById('sound-type-select');
    const testKeyButton = document.getElementById('test-key-button');
    const deleteKeyButton = document.getElementById('delete-key-button');
    const testKeyResult = document.getElementById('test-key-result');
    const autoResponsePromptTextarea = document.getElementById('auto-response-prompt-textarea');
    const summaryPromptTextarea = document.getElementById('summary-prompt-textarea'); // ★追加: チャット概要生成プロンプト

    // CSVインポート関連
    const importCsvInput = document.getElementById('import-csv-input');
    const exportCsvButton = document.getElementById('export-csv-button');

    // 全チャット履歴エクスポート/インポート関連
    const exportAllHistoryButton = document.getElementById('export-all-history-button');
    const importAllHistoryInput = document.getElementById('import-all-history-input');
    
    // メッセージ編集モーダル関連
    const editMessageModal = document.getElementById('edit-message-modal');
    const closeEditMessageModal = document.getElementById('close-edit-message-modal');
    const editMessageTextarea = document.getElementById('edit-message-textarea');
    const saveEditedMessageButton = document.getElementById('save-edited-message-button');
    
    // チャット履歴リストモーダル関連
    const chatHistoryListModal = document.getElementById('chat-history-list-modal');
    const closeChatHistoryListModal = document.getElementById('close-chat-history-list-modal');
    const chatHistoryList = document.getElementById('chat-history-list');
    const chatHistorySearchInput = document.getElementById('chat-history-search-input'); // 検索入力欄
    const selectAllHistoryButton = document.getElementById('select-all-history-button'); // 全選択ボタン
    const deselectAllHistoryButton = document.getElementById('deselect-all-history-button'); // 全解除ボタン
    const deleteSelectedHistoryButton = document.getElementById('delete-selected-history-button'); // 選択を削除ボタン
    const loadSelectedHistoryButton = document.getElementById('load-selected-history-button'); // 選択を読込ボタン
    
    // 並べ替え関連のDOM要素
    const sortBySelect = document.getElementById('sort-by-select');
    const sortOrderButton = document.getElementById('sort-order-button');
    const sortOrderIcon = document.getElementById('sort-order-icon');


    // PDF Viewer Modal関連
    const pdfViewerModal = document.getElementById('pdf-viewer-modal');
    const closePdfViewerModal = document.getElementById('close-pdf-viewer-modal');
    const pdfFrame = document.getElementById('pdf-frame');
    const downloadPdfButton = document.getElementById('download-pdf-button');

    // 絵文字ボタン関連
    const emojiButtons = document.querySelectorAll('.emoji-button');


    // グローバル変数
    let apiKey = '';
    let conversationHistory = [];
    let attachedImage = null;
    let timerId = null;
    let displayTimerId = null;
    let timerTargetTime = null;
    let editingMessageElement = null; // 編集中のメッセージ要素を保持
    let currentActiveSummaryData = null; // PDF印刷のために現在のサマリーデータを保持
    
    // 並べ替え設定用のグローバル変数とlocalStorageからの読み込み
    let currentSortBy = localStorage.getItem('chatHistorySortBy') || 'date';
    let currentSortOrder = localStorage.getItem('chatHistorySortOrder') || 'desc'; // 'asc' or 'desc'


    // --- 初期化処理 ---
    document.addEventListener('DOMContentLoaded', () => {
        apiKey = localStorage.getItem('geminiApiKey') || '';
        if (apiKey) apiKeyInput.value = apiKey;

        soundOnOff.checked = localStorage.getItem('soundEnabled') !== 'false';
        soundTypeSelect.value = localStorage.getItem('soundType') || 'sine';

        loadChatHistory(); // ロード時に履歴を読み込む
        updateCurrentDateTime();
        setInterval(updateCurrentDateTime, 60000); // 1分ごとに更新
        if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
            micButton.style.display = 'none';
        }
        // 初期設定をローカルストレージから読み込む（もしあれば）
        loadSettingsFromLocalStorage();

        // 並べ替え設定のロードとUIの更新
        sortBySelect.value = currentSortBy;
        sortOrderIcon.textContent = (currentSortOrder === 'asc' ? '↑' : '↓');

        // 絵文字ボタンのテキストを設定
        const defaultEmojis = ['😊', '😂', '💖', '✨', '👍', '🤔', '🎉', '🙏', '🌟', '💡'];
        emojiButtons.forEach((button, index) => {
            if (defaultEmojis[index]) {
                button.textContent = defaultEmojis[index];
            }
        });
    });

    // --- イベントリスナー設定 ---

    newChatButton.addEventListener('click', () => startNewChat(false));
    saveChatSummaryButton.addEventListener('click', () => { if (checkApiKey()) createChatSummary(); });
    loadChatHistoryButton.addEventListener('click', () => { 
        displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder); // 並べ替え設定を渡す
        chatHistoryListModal.style.display = 'block'; 
    });
    
    // PDF印刷ボタンのイベントリスナーを変更
    printPdfButton.addEventListener('click', () => {
        if (!currentActiveSummaryData) {
            alert("プレビューするチャット履歴がありません。チャットを保存するか、履歴を読み込んでください。");
            return;
        }
        showPdfPreviewOfChatSummary();
    });
    
    helpButton.addEventListener('click', showHelp);
    
    function sendMessage() {
        if (textInput.value.trim() !== '' || attachedImage) {
            if (!checkApiKey()) return;
            handleUserInput(textInput.value);
            textInput.value = '';
        }
    }
    
    sendButton.addEventListener('click', sendMessage);
    textInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });

    textInput.addEventListener('paste', handlePaste);
    fileInputButton.addEventListener('click', () => imageFileInput.click());
    imageFileInput.addEventListener('change', handleFileSelect);
    removeImageButton.addEventListener('click', removeAttachedImage);
    
    settingsButton.addEventListener('click', () => {
        testKeyResult.textContent = '';
        testKeyResult.className = '';
        settingsModal.style.display = 'block';
    });
    closeSettingsModal.addEventListener('click', () => { settingsModal.style.display = 'none'; });
    saveKeyButton.addEventListener('click', () => {
        const newKey = apiKeyInput.value.trim();
        if (newKey) {
            apiKey = newKey;
            localStorage.setItem('geminiApiKey', newKey);
            settingsModal.style.display = 'none';
            alert('APIキーを保存しました。');
        } else {
            alert('APIキーを入力してください。');
        }
    });
    testKeyButton.addEventListener('click', testApiKey);
    deleteKeyButton.addEventListener('click', deleteApiKey);

    personaButton.addEventListener('click', () => {
        // 設定をローカルストレージから読み込む
        loadSettingsFromLocalStorage(); // 各種設定モーダルを開く際に最新の設定を読み込む
        personaModal.style.display = 'block';
    });

    closePersonaModal.addEventListener('click', () => { personaModal.style.display = 'none'; });
    saveSettingsButton.addEventListener('click', () => {
        saveSettingsToLocalStorage(); // 設定をローカルストレージに保存
        personaModal.style.display = 'none';
        alert('設定を保存しました。');
    });
    personaExampleBtns.forEach(btn => {
        btn.addEventListener('click', () => { personaTextarea.value = btn.dataset.persona; });
    });

    // CSVエクスポートボタンのイベントリスナー
    exportCsvButton.addEventListener('click', exportSettingsAsCsv);
    // CSVインポートボタンのイベントリスナーはinput要素のchangeイベントのみに任せる (ラベルのfor属性がinputをトリガーするため)
    importCsvInput.addEventListener('change', importSettingsFromCsv);

    // 全チャット履歴エクスポート/インポートボタンのイベントリスナー
    exportAllHistoryButton.addEventListener('click', exportAllChatSummaries);
    importAllHistoryInput.addEventListener('change', importAllChatSummaries);

    timerStartButton.addEventListener('click', handleTimerStart);
    timerStopButton.addEventListener('click', stopTimer);
    deleteSelectedButton.addEventListener('click', deleteSelectedMessages);
    editSelectedButton.addEventListener('click', openEditMessageModal); // 編集ボタンのイベントリスナーを追加

    micButton.addEventListener('click', () => {
        if (!checkApiKey()) return;
        if (isRecording) {
            recognition.stop();
        } else {
            recognition.start();
        }
    });

    window.addEventListener('click', (event) => {
        if (event.target == personaModal) personaModal.style.display = 'none';
        if (event.target == settingsModal) settingsModal.style.display = 'none';
        if (event.target == editMessageModal) editMessageModal.style.display = 'none'; // 編集モーダルの背景クリックで閉じる
        // if (event.target == chatHistoryListModal) chatHistoryListModal.style.display = 'none'; // 履歴リストモーダルの背景クリックで閉じる (検索機能があるため、明示的に閉じるボタンで閉じるように変更)
        if (event.target == pdfViewerModal) {
            pdfViewerModal.style.display = 'none';
            pdfFrame.src = ''; // iframeのソースをクリア
        }
    });
    
    // チャット履歴リストモーダルの閉じるボタン
    closeChatHistoryListModal.addEventListener('click', () => { chatHistoryListModal.style.display = 'none'; });
    // 検索入力欄のイベントリスナー
    chatHistorySearchInput.addEventListener('input', () => displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder));
    
    // 並べ替えセレクタのイベントリスナー
    sortBySelect.addEventListener('change', (event) => {
        currentSortBy = event.target.value;
        localStorage.setItem('chatHistorySortBy', currentSortBy);
        displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder);
    });

    // 並べ替え順序ボタンのイベントリスナー
    sortOrderButton.addEventListener('click', () => {
        currentSortOrder = (currentSortOrder === 'asc' ? 'desc' : 'asc');
        localStorage.setItem('chatHistorySortOrder', currentSortOrder);
        sortOrderIcon.textContent = (currentSortOrder === 'asc' ? '↑' : '↓');
        displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder);
    });


    // 全選択ボタン
    selectAllHistoryButton.addEventListener('click', () => {
        document.querySelectorAll('.history-item-checkbox').forEach(checkbox => {
            checkbox.checked = true;
        });
    });
    // 全解除ボタン
    deselectAllHistoryButton.addEventListener('click', () => {
        document.querySelectorAll('.history-item-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
    });
    // 選択を削除ボタン
    deleteSelectedHistoryButton.addEventListener('click', () => {
        const checkedCheckboxes = document.querySelectorAll('.history-item-checkbox:checked');
        if (checkedCheckboxes.length === 0) {
            alert('削除する項目を選択してください。');
            return;
        }
        if (confirm(`${checkedCheckboxes.length}件の履歴を削除しますか？`)) {
            let allSummaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
            const filenamesToDelete = Array.from(checkedCheckboxes).map(checkbox => checkbox.dataset.filename);
            
            // 削除対象以外の履歴で新しい配列を作成
            allSummaries = allSummaries.filter(summary => !filenamesToDelete.includes(summary.filename));
            
            localStorage.setItem('chatSummaries', JSON.stringify(allSummaries));
            displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder); // リストを更新
            alert(`${checkedCheckboxes.length}件の履歴を削除しました。`);
        }
    });
    // 選択を読込ボタン
    loadSelectedHistoryButton.addEventListener('click', () => {
        const checkedCheckboxes = document.querySelectorAll('.history-item-checkbox:checked');
        if (checkedCheckboxes.length === 0) {
            alert('読み込む項目を選択してください。');
            return;
        }
        
        let selectedSummaries = [];
        const allSummaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
        checkedCheckboxes.forEach(checkbox => {
            const filenameToLoad = checkbox.dataset.filename; // data-filename から取得
            const summary = allSummaries.find(s => s.filename === filenameToLoad);
            if (summary) {
                selectedSummaries.push(summary);
            }
        });

        if (selectedSummaries.length > 0) {
            // 最も新しい日付の履歴を読み込む (ソートされていても、選択された中から最新を読み込む)
            selectedSummaries.sort((a, b) => new Date(b.date) - new Date(a.date));
            loadChatFromSummary(selectedSummaries[0]);
            chatHistoryListModal.style.display = 'none'; // モーダルを閉じる
            alert(`「${selectedSummaries[0].title}」を読み込みました。`);
        } else {
            alert('有効な履歴が選択されていません。');
        }
    });

    // PDF Viewer Modalの閉じるボタン
    closePdfViewerModal.addEventListener('click', () => {
        pdfViewerModal.style.display = 'none';
        pdfFrame.src = ''; // iframeのソースをクリア
    });

    // 絵文字ボタンのイベントリスナー
    emojiButtons.forEach(button => {
        button.addEventListener('click', (event) => {
            event.preventDefault(); // ボタンクリックでフォーム送信を防ぐ
            const emoji = button.dataset.emoji;
            textInput.value += emoji;
            textInput.focus();
        });
    });


    // --- チャット関連の関数 ---

    function startNewChat(isInitial) {
        if (!isInitial && conversationHistory.length > 0) {
            if (confirm("現在のチャット内容を破棄しますか？")) {
                // 破棄するので、保存はしない
            } else {
                return; // キャンセル
            }
        }
        chatBox.innerHTML = '';
        conversationHistory = [];
        localStorage.removeItem('conversationHistory'); // 現在の会話履歴をクリア
        
        // チャット保存ボタン、履歴一覧ボタン、新しいチャットボタンのみ表示
        saveChatSummaryButton.style.display = 'inline-flex';
        loadChatHistoryButton.style.display = 'inline-flex';
        printPdfButton.style.display = 'none'; // 新しいチャットでは非表示
        newChatButton.style.display = 'inline-flex';
        
        // 削除・編集ボタンは非表示
        deleteSelectedButton.style.display = 'none';
        editSelectedButton.style.display = 'none';
        
        currentActiveSummaryData = null; // currentActiveSummaryData をクリア
        removeAttachedImage();
        stopTimer();

        if (isInitial && !apiKey) {
            addMessage("こんにちは！「API設定」ボタンからAPIキーを設定してください。", 'bot');
        } else {
            const userName = localStorage.getItem('userName') || 'あなた';
            const aiName = localStorage.getItem('aiName') || 'AI';
            const greetingMessage = `こんにちは、${userName}さん！${aiName}です。何でも話しかけてください。`;
            addMessage(greetingMessage, 'bot');
        }
        textInput.focus();
        updateDeleteButtonVisibility();
    }

    function loadChatHistory() {
        const savedHistory = localStorage.getItem('conversationHistory');
        if (savedHistory) {
            try {
                conversationHistory = JSON.parse(savedHistory);
                chatBox.innerHTML = '';
                conversationHistory.forEach(item => {
                    addMessage(item.content, item.role === 'user' ? 'user' : 'bot', { timestamp: item.timestamp, image: item.image });
                });
                // アプリケーション起動時に履歴があった場合、PDF印刷ボタンを表示
                if (conversationHistory.length > 0) {
                    // ただし、currentActiveSummaryDataは保存していないので、純粋な会話履歴のみからの復帰ではPDF印刷はできないようにする
                    // currentActiveSummaryData は `loadChatFromSummary` または `createChatSummary` で設定されるべき
                    printPdfButton.style.display = 'none'; // 詳細情報がないのでPDF印刷は非表示に
                }
            } catch (e) {
                console.error("チャット履歴の解析に失敗しました:", e);
                localStorage.removeItem('conversationHistory');
                startNewChat(true);
            }
        } else {
            startNewChat(true);
        }
        updateDeleteButtonVisibility();
    }

    function saveChatHistory() {
        try {
            localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory));
        } catch (error) {
            if (error.name === 'QuotaExceededError') {
                console.error("会話履歴の自動保存に失敗: ブラウザの保存容量の上限を超えました。");
            } else {
                console.error("会話履歴の保存中に不明なエラーが発生しました:", error);
            }
        }
    }

    function handleUserInput(message) {
        if (!message.trim() && !attachedImage) return;
        addMessage(message, 'user', { image: attachedImage });
        conversationHistory.push({
            role: 'user', content: message, image: attachedImage,
            timestamp: new Date().toISOString()
        });
        saveChatHistory();
        getAIResponse(false); // 自動応答ではない
        removeAttachedImage();
    }

    async function getAIResponse(isAutoResponse = false) {
        if (!checkApiKey()) return; // APIキーがなければ応答しない
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        const thinkingMessage = addMessage('考え中...', 'bot');

        let contents = conversationHistory.map(item => {
            const parts = [];
            if (item.content && item.content.trim() !== '') parts.push({ text: item.content });
            if (item.role === 'user' && item.image) {
                parts.push({ inlineData: { mimeType: item.image.mimeType, data: item.image.base64 } });
            }
            return { role: item.role === 'user' ? 'user' : 'model', parts: parts.length > 0 ? parts : [{ text: '' }] };
        });

        if (isAutoResponse) {
            const autoPrompt = localStorage.getItem('autoResponsePrompt') || '時間になりました。自然な会話の流れで、何か新しい話題を提供したり、私に質問をしてみてください。';
            contents.push({ role: 'user', parts: [{ text: autoPrompt }] });
        }

        const requestBody = { contents };
        const persona = localStorage.getItem('geminiPersona');
        if (persona) requestBody.systemInstruction = { parts: [{ text: persona }] };

        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (thinkingMessage && thinkingMessage.parentNode) chatBox.removeChild(thinkingMessage);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`APIエラー: ${response.status} - ${errorData.error?.message || JSON.stringify(errorData)}`);
            }
            const data = await response.json();
            // Optional Chaining の修正
            if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text) {
                const aiResponse = data.candidates[0].content.parts[0].text;
                addMessage(aiResponse, 'bot');
                if (localStorage.getItem('soundEnabled') !== 'false') {
                    playNotificationSound(localStorage.getItem('soundType') || 'sine');
                }
                conversationHistory.push({ role: 'assistant', content: aiResponse, timestamp: new Date().toISOString() });
                saveChatHistory();
            } else {
                 throw new Error("APIから有効な応答が返されませんでした。");
            }
        } catch (error) {
            console.error('Fetchエラー:', error);
            if (thinkingMessage && thinkingMessage.parentNode) chatBox.removeChild(thinkingMessage);
            let errorMessage = `エラーが発生しました: ${error.message}`;
            if (String(error.message).includes('429')) {
                errorMessage = 'APIのリクエスト上限に達しました。しばらく時間をおいてから再度お試しください。';
            }
            addMessage(errorMessage, 'bot', { isError: true });
        }
    }

    function addMessage(text, sender, options = {}) {
        const { isError = false, isSummary = false, timestamp = null, image = null } = options;
        const messageElement = document.createElement('div');
        let messageClass = sender === 'user' ? 'user-message' : (isError ? 'error-message' : (isSummary ? 'summary-message' : 'bot-message'));
        messageElement.classList.add('message', messageClass);
        const messageTimestamp = timestamp ? new Date(timestamp) : new Date();
        messageElement.dataset.id = messageTimestamp.getTime();
        if (!isSummary) {
            messageElement.addEventListener('click', () => {
                messageElement.classList.toggle('selected');
                updateDeleteButtonVisibility();
            });
        }
        if (image) {
            const imgElement = document.createElement('img');
            imgElement.src = `data:${image.mimeType};base64,${image.base64}`;
            imgElement.classList.add('message-image');
            messageElement.appendChild(imgElement);
        }
        const textElement = document.createElement('div');

        // URLを検出し、不要な前後の記号（[]や()）を除去してリンク化する正規表現
        const urlRegex = /(?:^|(?<=\s))\[?(https?:\/\/[^\s]+?)(?:\]|\)|\.)?(?=\s|$)/g;

        let processedText = (text || '').replace(/\n/g, '<br>');
        processedText = processedText.replace(urlRegex, (match, url) => {
            let cleanUrl = url.replace(/^[.,!?:;\]\)]+|[.,!?:;\]\)]+$/g, '');
            return `<a href="${cleanUrl}" target="_blank">${cleanUrl}</a>`;
        });

        textElement.innerHTML = processedText;

        if(text || (!text && !image)) messageElement.appendChild(textElement);
        const timestampElement = document.createElement('div');
        timestampElement.classList.add('timestamp');
        timestampElement.textContent = formatTimestamp(messageTimestamp);
        messageElement.appendChild(timestampElement);
        chatBox.appendChild(messageElement);
        chatBox.scrollTop = chatBox.scrollHeight;
        return messageElement;
    }
    
    async function testApiKey() {
        const keyToTest = apiKeyInput.value.trim();
        if (!keyToTest) { alert('テストするAPIキーを入力してください。'); return; }
        testKeyResult.textContent = 'テスト中...';
        testKeyResult.className = '';
        const testApiUrl = `https://generativelanguage.googleapis.com/v1beta/models?key=${keyToTest}`;
        try {
            const response = await fetch(testApiUrl);
            if (response.ok) {
                testKeyResult.textContent = '✅ APIキーは有効です。';
                testKeyResult.className = 'test-success';
            } else {
                const errorData = await response.json();
                testKeyResult.textContent = `❌ 無効なAPIキーです: ${errorData.error.message}`;
                testKeyResult.className = 'test-failure';
            }
        } catch (error) {
            console.error('APIキーテストエラー:', error);
            testKeyResult.textContent = '❌ テストに失敗しました。ネットワーク接続を確認してください。';
            testKeyResult.className = 'test-failure';
        }
    }

    function deleteApiKey() {
        if (confirm('保存されているAPIキーを削除しますか？')) {
            apiKey = ''; apiKeyInput.value = ''; localStorage.removeItem('geminiApiKey');
            alert('APIキーを削除しました。');
            testKeyResult.textContent = ''; testKeyResult.className = '';
        }
    }

    // --- チャット保存・履歴表示関連の関数 ---
    async function createChatSummary() {
        if (conversationHistory.length === 0) { alert('保存するチャットがありません。'); return; }
        let statusMessage;
        try {
            statusMessage = addMessage(`チャット内容を分析して保存しています...`, 'bot');
            const userName = localStorage.getItem('userName') || 'あなた';
            const aiName = localStorage.getItem('aiName') || 'AI';

            // 会話履歴のテキスト部分を抽出
            const conversationText = conversationHistory
                .filter(item => !item.image) // 画像はプロンプトに含めない
                .map(item => `${item.role === 'user' ? userName : aiName}: ${item.content || ''}`)
                .join('\n');
            
            const today = new Date();
            // ファイル名用日付フォーマット: YYYYMMDD (ファイル名には時刻を含めずシンプルに)
            const formattedDateForFileName = `${today.getFullYear()}${('0' + (today.getMonth() + 1)).slice(-2)}${('0' + today.getDate()).slice(-2)}`;
            // 履歴データ用日付フォーマット: ISO文字列 (時刻情報も含む)
            const dateForSummaryData = today.toISOString(); // ここを修正

            // AIへのプロンプトをJSON形式での出力指示に修正 (ユーザー設定から取得)
            const defaultSummaryPrompt = `以下の会話履歴を基に、簡潔なタイトル（30文字程度）と、会話の要約を箇条書きにして作成し、JSON形式で出力してください。\n\n出力は以下のJSONフォーマットに従ってください。\n{\n  "title": "ここにタイトルを記述 (15文字程度)",\n  "summary": "ここに会話の要約を記述 (第三者の視点から自然な文章で)"\n}\n\n---\n[会話履歴]\n{CONVERSATION_HISTORY}\n---`;
            let summaryPromptTemplate = localStorage.getItem('summaryPrompt') || defaultSummaryPrompt;
            
            // テンプレート中の {CONVERSATION_HISTORY} を実際の会話履歴で置き換える
            const summaryPrompt = summaryPromptTemplate.replace('{CONVERSATION_HISTORY}', conversationText);

            const summaryApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const summaryContents = [{ role: 'user', parts: [{ text: summaryPrompt }] }];
            const summaryResponse = await fetch(summaryApiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: summaryContents }) });
            
            if (!summaryResponse.ok) {
                const errorData = await summaryResponse.json(); 
                throw new Error(`概要生成APIエラー: ${summaryResponse.status} - ${errorData.error?.message || JSON.stringify(errorData)}`);
            }
            const data = await summaryResponse.json();
            let generatedText = "";
            // Optional Chaining の修正
            if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] && data.candidates[0].content.parts[0].text) {
                generatedText = data.candidates[0].content.parts[0].text.trim();
            } else {
                throw new Error("APIから有効な応答が返されませんでした。");
            }

            let title = '無題のチャット'; // デフォルトタイトル
            let summary = '概要が生成されませんでした。'; // デフォルト概要

            try {
                // Markdownコードブロック記法を削除してからJSONとしてパース
                const cleanGeneratedText = generatedText.replace(/```json\n?|\n?```/g, '').trim();
                const parsedContent = JSON.parse(cleanGeneratedText);
                if (parsedContent.title) {
                    title = parsedContent.title.trim();
                }
                if (parsedContent.summary) {
                    summary = parsedContent.summary.trim();
                }
            } catch (jsonError) {
                console.warn("AI応答のJSON解析に失敗しました。生のテキストからタイトルと概要を試みます。", jsonError);
                // JSON解析に失敗した場合のフォールバックロジック (Markdown形式で返された場合など)
                // 最初の行をタイトルとして、残りを概要として扱う
                const lines = generatedText.split(/[\n\r]+/);
                if (lines.length > 0) {
                    // タイトルは最初の行から取得し、不要なプレフィックスを削除
                    title = lines[0].replace(/^\*\*タイトル:\*\*\s*/, '').trim();
                    if (title === '') title = '無題のチャット';

                    // 概要は2行目以降を結合し、不要なプレフィックスを削除
                    let remainingSummary = lines.slice(1).join('\n').trim();
                    summary = remainingSummary.replace(/^\*\*概要:\*\*\s*/, '').trim();
                    if (summary === '') summary = '概要が生成されませんでした。';
                }
            }

            // ファイル名として安全なタイトル文字列を生成
            const safeTitleForFilename = title.replace(/[\\/:*?"<>|]/g, '_').substring(0, 50); 
            // ファイル名を YYYYMMDD_タイトル.md 形式に
            const filename = `${formattedDateForFileName}_${safeTitleForFilename}.md`;

            const chatSummaryData = { 
                title, 
                summary, 
                history: [...conversationHistory], 
                date: dateForSummaryData, // ISO形式の完全な時刻情報を含む文字列で保存
                filename: filename // 生成したファイル名を保存
            };
            
            downloadChatSummaryMarkdown(chatSummaryData, chatSummaryData.filename);
            
            if (statusMessage && statusMessage.parentNode) chatBox.removeChild(statusMessage);
            try {
                saveChatSummary(chatSummaryData); // チャット履歴リストに保存
                alert(`チャットを保存しました: ${chatSummaryData.title}`); // ユーザーにはタイトルで通知
                displayChatSummaryInChatBox(chatSummaryData); // 保存後、チャット欄に表示
                currentActiveSummaryData = chatSummaryData; // PDF印刷用にデータを設定
                printPdfButton.style.display = 'inline-flex'; // PDF印刷ボタンを表示
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    throw new Error("ブラウザの保存容量の上限を超えました。ファイルはダウンロードされましたが、履歴リストには保存できませんでした。");
                } else { throw error; }
            }
        } catch (error) {
            console.error('チャット保存プロセスエラー:', error);
            if (statusMessage && statusMessage.parentNode) {
                statusMessage.textContent = `チャットの保存に失敗しました: ${error.message}`;
                statusMessage.className = 'message error-message';
            } else { addMessage(`チャットの保存に失敗しました: ${error.message}`, 'bot', { isError: true }); }
        }
    }

    function saveChatSummary(chatSummaryData) {
        const summaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
        // 重複チェック（filenameでチェックし、あれば更新、なければ追加）
        const existingIndex = summaries.findIndex(item => item.filename === chatSummaryData.filename);
        if (existingIndex > -1) {
            summaries[existingIndex] = chatSummaryData; // 更新
        } else {
            summaries.push(chatSummaryData);
        }
        localStorage.setItem('chatSummaries', JSON.stringify(summaries));
    }

    // チャット欄に保存したチャットのタイトル、概要、履歴を表示する関数
    function displayChatSummaryInChatBox(summaryData) {
        chatBox.innerHTML = ''; // 現在のチャット内容をクリア
        
        // ファイル名を表示
        const filenameElement = document.createElement('div');
        filenameElement.classList.add('message', 'summary-message'); // スタイルを流用
        // ファイル名と保存日時を表示
        filenameElement.innerHTML = `<h3>ファイル名: ${summaryData.filename}</h3><p>保存日時: ${formatTimestamp(new Date(summaryData.date))}</p>`;
        chatBox.appendChild(filenameElement);

        // タイトルと概要をまとめたメッセージとして表示 (Markdownコードブロックではない)
        const summaryElement = document.createElement('div');
        summaryElement.classList.add('message', 'summary-message');
        // `summaryData.summary` はすでに整形された概要テキストなので、そのまま表示
        summaryElement.innerHTML = `<h2>${summaryData.title}</h2><p>${summaryData.summary.replace(/\n/g, '<br>')}</p><hr><h3>チャット履歴 (保存時)</h3>`;
        chatBox.appendChild(summaryElement);

        // 保存された履歴をチャットボックスに追加
        conversationHistory = summaryData.history; // 現在の会話履歴を上書き
        localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); // ローカルストレージも更新
        summaryData.history.forEach(item => {
            addMessage(item.content, item.role === 'user' ? 'user' : 'bot', { timestamp: item.timestamp, image: item.image });
        });

        chatBox.scrollTop = chatBox.scrollHeight; // スクロールを一番下へ
        updateDeleteButtonVisibility(); // ボタンの表示状態を更新
        currentActiveSummaryData = summaryData; // PDF印刷用にデータを設定
        printPdfButton.style.display = 'inline-flex'; // PDF印刷ボタンを表示
    }


    function displayChatHistoryList(searchTerm = '', sortBy = 'date', sortOrder = 'desc') { // 検索キーワード、並べ替え基準、順序を受け取るように変更
        chatHistoryList.innerHTML = ''; // リストをクリア
        const allSummaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
        
        // 検索キーワードでフィルタリング
        const filteredSummaries = allSummaries.filter(summary => {
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            const filename = (summary.filename || '').toLowerCase(); // null/undefined対策
            const title = (summary.title || '').toLowerCase();
            const date = (summary.date ? formatTimestamp(new Date(summary.date)) : '').toLowerCase(); // 日付も時刻込みで検索対象に含める

            return filename.includes(lowerCaseSearchTerm) ||
                   title.includes(lowerCaseSearchTerm) ||
                   date.includes(lowerCaseSearchTerm);
        });

        // 並べ替えロジック
        filteredSummaries.sort((a, b) => {
            let compareA, compareB;

            if (sortBy === 'date') {
                compareA = new Date(a.date); // ISO文字列からDateオブジェクトに変換
                compareB = new Date(b.date);
            } else if (sortBy === 'title') {
                compareA = a.title || '';
                compareB = b.title || '';
            }

            let comparison = 0;
            if (compareA > compareB) {
                comparison = 1;
            } else if (compareA < compareB) {
                comparison = -1;
            }

            return sortOrder === 'asc' ? comparison : -comparison; // 昇順または降順
        });


        if (filteredSummaries.length === 0) {
            chatHistoryList.innerHTML = '<li>保存されたチャット履歴はありません。</li>';
            if (searchTerm) {
                chatHistoryList.innerHTML = `<li>「${searchTerm}」に一致する履歴は見つかりませんでした。</li>`;
            }
            return;
        }

        filteredSummaries.forEach((summary) => { // index は不要なので削除
            const listItem = document.createElement('li');
            // 履歴一覧にはタイトルと保存日時を表示
            const displayDate = summary.date ? formatTimestamp(new Date(summary.date)) : '不明な日時'; // 時刻込みで表示
            
            listItem.innerHTML = `
                <input type="checkbox" class="history-item-checkbox" data-filename="${summary.filename}">
                <div class="history-item-content">
                    <div class="title">${summary.title}</div> <!-- タイトルを表示 -->
                    <div class="date-time">${displayDate}</div> <!-- 保存日時を表示 -->
                </div>
            `;
            
            chatHistoryList.appendChild(listItem);
        });
    }
    
    // ファイル名でチャットサマリーを削除する関数
    function deleteChatSummaryByFilename(filenameToDelete) {
        let summaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
        summaries = summaries.filter(summary => summary.filename !== filenameToDelete);
        localStorage.setItem('chatSummaries', JSON.stringify(summaries));
        displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder); // リストを更新
    }

    // `deleteChatSummary(index)` はもう使われないため削除しました。


    function loadChatFromSummary(summaryData) {
        chatBox.innerHTML = '';
        conversationHistory = summaryData.history;
        localStorage.setItem('conversationHistory', JSON.stringify(conversationHistory)); // 現在の会話履歴としても保存
        // 履歴ロード時に、チャット欄にも保存時の情報と履歴を表示
        displayChatSummaryInChatBox(summaryData); 
        
        // UIの状態を更新
        saveChatSummaryButton.style.display = 'inline-flex';
        loadChatHistoryButton.style.display = 'inline-flex';
        newChatButton.style.display = 'inline-flex';
        deleteSelectedButton.style.display = 'none';
        editSelectedButton.style.display = 'none';
        updateDeleteButtonVisibility();

        currentActiveSummaryData = summaryData; // PDF印刷用にデータを設定
        printPdfButton.style.display = 'inline-flex'; // PDF印刷ボタンを表示
    }

    function downloadChatSummaryMarkdown(summaryData, filename) {
        let markdownContent = `# ${summaryData.title}\n\n`;
        // summaryData.date はISO文字列なので、new Date() で変換してからformatTimestamp
        markdownContent += `**保存日時:** ${formatTimestamp(new Date(summaryData.date))}\n\n`; // ここを修正
        markdownContent += `## 概要\n\n`;
        // summaryData.summary はすでに整形された概要
        // HTMLの<br>タグをMarkdownの改行に変換して出力
        const summaryContent = summaryData.summary.replace(/<br>/g, '\n'); 
        summaryContent.split('\n').forEach(line => { markdownContent += `> ${line}\n`; });
        markdownContent += `\n---\n\n`;
        markdownContent += `# チャット履歴\n\n`;

        const userName = localStorage.getItem('userName') || 'ユーザー';
        const aiName = localStorage.getItem('aiName') || 'AI';
        
        summaryData.history.forEach(item => {
            const speaker = item.role === 'user' ? userName : aiName;
            const timestamp = formatTimestamp(new Date(item.timestamp));
            markdownContent += `**${speaker}** (${timestamp}):\n`;
            if (item.image) markdownContent += `> (画像添付)\n`;
            if (item.content) item.content.split('\n').forEach(line => { markdownContent += `> ${line}\n`; });
            markdownContent += `\n`;
        });

        downloadMarkdown(markdownContent, filename);
    }

    // --- PDF印刷/プレビュー関連の関数 ---
    async function showPdfPreviewOfChatSummary() {
        if (!currentActiveSummaryData) {
            alert('PDFを生成するチャット履歴がありません。');
            return;
        }

        const userName = localStorage.getItem('userName') || 'ユーザー';
        const aiName = localStorage.getItem('aiName') || 'AI';
        
        // --- PDF生成用のHTMLコンテンツを準備 ---
        let contentForPdf = `
            <div style="font-family: 'Helvetica Neue', 'Arial', 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif; line-height: 1.6; padding: 20px; color: #333; margin: 0; background-color: #fff;">
                <h1 style="color: #2e8b57; border-bottom: 2px solid #eee; padding-bottom: 5px; font-size: 1.8em; margin-bottom: 15px;">${currentActiveSummaryData.title}</h1>
                <p><strong>ファイル名:</strong> ${currentActiveSummaryData.filename}</p>
                <p><strong>保存日時:</strong> ${formatTimestamp(new Date(currentActiveSummaryData.date))}</p>
                
                <h2 style="color: #3cb371; font-size: 1.5em; margin-top: 25px; margin-bottom: 10px;">概要</h2>
                <div class="summary-content">
                    <p style="margin-top: 5px; margin-bottom: 0;">${currentActiveSummaryData.summary.replace(/\n/g,'<br>')}</p>
                </div>
                
                <hr style="border: 0; border-top: 1px dashed #ccc; margin: 20px 0;">
                <h2 style="color: #3cb371; font-size: 1.5em; margin-top: 25px; margin-bottom: 10px;">チャット履歴</h2>
                <div class="chat-log">`;

        currentActiveSummaryData.history.forEach(item => {
            const speaker = item.role === 'user' ? userName : aiName;
            // PDF出力時は、classではなくstyle属性で直接スタイルを適用します
            const messageStyle = `margin-bottom: 5px; padding: 8px 12px; border-radius: 8px; max-width: 100%; word-wrap: break-word; page-break-inside: avoid; background-color: ${item.role === 'user' ? '#e0f0e0' : '#f0f0f0'}; ${item.role === 'user' ? 'text-align: right; margin-left: auto;' : 'text-align: left;'};`;
            const timestampStyle = `font-size: 0.75em; color: #888; margin-top: 2px; display: block; ${item.role === 'user' ? 'text-align: right;' : 'text-align: left;'};`;

            contentForPdf += `<div class="message" style="${messageStyle}">
                                <span class="speaker" style="font-weight: bold; margin-bottom: 0px; display: block;">${speaker}</span>`;
            if (item.image && item.image.base64) {
                contentForPdf += `<img src="data:${item.image.mimeType};base64,${item.image.base64}" class="message-image" alt="添付画像" style="max-width: 80%; height: auto; border-radius: 5px; margin-top: 5px; display: block; margin-left: auto; margin-right: auto;"><br>`;
            }
            if (item.content) {
                contentForPdf += `<div class="message-content" style="margin-top: 2px;">${item.content.replace(/\n/g,'<br>')}</div>`;
            }
            contentForPdf += `<span class="timestamp" style="${timestampStyle}">(${formatTimestamp(new Date(item.timestamp))})</span>
                            </div>`;
        });

        contentForPdf += `</div></div>`; // chat-log と外側の div を閉じる

        // --- html2pdf.js を使用してPDFを生成 ---
        const options = {
            margin: 10,
            filename: `${currentActiveSummaryData.title}_${toDateString(new Date(currentActiveSummaryData.date))}.pdf`, // PDFダウンロード時のファイル名を生成
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, logging: false, dpi: 192, letterRendering: true, useCORS: true },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };

        try {
            // html2pdfに渡すために一時的な要素を作成
            const element = document.createElement('div');
            element.innerHTML = contentForPdf;

            // Workerインスタンスを作成し、optionsを設定
            const worker = html2pdf().from(element).set(options);

            // jsPDFインスタンスを取得してPDFのメタデータを設定
            const pdfDoc = await worker.toPdf().get('pdf');
            pdfDoc.setProperties({
                title: currentActiveSummaryData.title, // ここでPDFのタイトルメタデータを設定
                subject: currentActiveSummaryData.summary,
                author: userName,
                creator: 'Myチャット履歴 Ver1.06', // バージョンを更新
                keywords: 'chat, summary, AI'
            });

            // 設定済みのjsPDFインスタンスからPDFをBlobとして出力
            const pdfBlob = await pdfDoc.output('blob');

            // Blob URLを作成し、iframeで表示
            const pdfUrl = URL.createObjectURL(pdfBlob);
            pdfFrame.src = pdfUrl;
            pdfViewerModal.style.display = 'block';

            // ダウンロードボタンにBlob URLを渡す
            downloadPdfButton.onclick = () => {
                const link = document.createElement('a');
                link.href = pdfUrl;
                link.download = options.filename; // ダウンロード時のファイル名はoptionsから
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                // URL.revokeObjectURL(pdfUrl); // 必要に応じてダウンロード後にURLを解放
            };

        } catch (error) {
            console.error('PDF生成エラー:', error);
            alert('PDFの生成に失敗しました: ' + error.message);
        }
    }


    // --- 音声認識関連の関数 (簡略化) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    let isRecording = false;
    let finalTranscript = '';

    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.lang = 'ja-JP';
        recognition.continuous = true;
        recognition.interimResults = false;
        recognition.onstart = () => {
            isRecording = true; finalTranscript = '';
            micButton.classList.add('recording'); micButton.textContent = '🎙️'; // 録音中のアイコン変更
            textInput.placeholder = '録音中...';
        };
        recognition.onresult = (event) => {
            let transcript = '';
            for (let i = event.results.length - 1; i >= 0; i--) { // 最新の結果から取得
                if (event.results[i].isFinal) {
                    transcript += event.results[i][0].transcript; 
                }
            }
            finalTranscript += transcript; // 蓄積
        };
        recognition.onend = () => {
            isRecording = false;
            micButton.classList.remove('recording'); micButton.textContent = '🎤';
            textInput.placeholder = 'メッセージを入力...';
            if (finalTranscript.trim()) {
                textInput.value += (textInput.value.length > 0 ? ' ' : '') + finalTranscript.trim();
                textInput.focus();
            }
        };
        recognition.onerror = (event) => {
            console.error('音声認識エラー:', event.error);
            if (isRecording) recognition.stop();
        };
    }

    // --- 画像処理関連の関数 ---
    function processImageFile(file) {
        if (!file.type.startsWith('image/')) { alert('画像ファイルを選択してください。'); return; }
        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target.result;
            imagePreview.src = dataUrl;
            imagePreviewContainer.style.display = 'block';
            const base64String = dataUrl.split(',')[1]; 
            const mimeType = dataUrl.match(/:(.*?);/)[1]; 
            attachedImage = { base64: base64String, mimeType: mimeType };
        };
        reader.readAsDataURL(file);
    }
    function handlePaste(event) {
        const items = (event.clipboardData || window.clipboardData).items;
        for (const item of items) {
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                event.preventDefault();
                processImageFile(item.getAsFile());
                return;
            }
        }
    }
    function handleFileSelect(event) { 
        if (event.target.files && event.target.files[0]) {
            processImageFile(event.target.files[0]); 
        }
    }
    function removeAttachedImage() {
        attachedImage = null; imagePreviewContainer.style.display = 'none';
        imagePreview.src = ''; imageFileInput.value = '';
    }

    // --- タイマー関連の関数 ---
    function handleTimerStart() {
        const minutes = parseInt(timerInput.value, 10);
        if (!minutes || minutes <= 0) { alert('1以上の数値を分単位で入力してください。'); return; }
        startTimer(minutes * 60 * 1000);
    }
    function startTimer(interval) {
        if (!checkApiKey()) return;
        stopTimer();
        timerId = setInterval(() => { timerTargetTime = Date.now() + interval; getAIResponse(true); }, interval);
        timerTargetTime = Date.now() + interval;
        displayTimerId = setInterval(updateTimerDisplay, 1000);
        updateTimerDisplay();
        timerStartButton.style.display = 'none';
        timerStopButton.style.display = 'inline-block';
        timerInput.disabled = true;
    }
    function stopTimer() {
        if (timerId) { clearInterval(timerId); timerId = null; }
        if (displayTimerId) { clearInterval(displayTimerId); displayTimerId = null; }
        timerDisplay.textContent = ''; timerInput.value = '';
        timerStartButton.style.display = 'inline-block';
        timerStopButton.style.display = 'none';
        timerInput.disabled = false;
    }
    function updateTimerDisplay() {
        if (!timerTargetTime) return;
        const remaining = timerTargetTime - Date.now();
        if (remaining <= 0) { timerDisplay.textContent = '応答中...'; return; }
        const totalSeconds = Math.floor(remaining / 1000);
        const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
        const seconds = (totalSeconds % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `次の応答: ${minutes}:${seconds}`;
    }
    
    // --- CSVエクスポート/インポート関連関数 ---

    function exportSettingsAsCsv() {
        const settings = {
            persona: personaTextarea.value.trim(),
            autoResponsePrompt: autoResponsePromptTextarea.value.trim(),
            summaryPrompt: summaryPromptTextarea.value.trim(), // ★追加: 概要生成プロンプト
            userName: userNameInput.value.trim(),
            aiName: aiNameInput.value.trim(),
            soundEnabled: soundOnOff.checked,
            soundType: soundTypeSelect.value,
        };

        // CSVヘッダー
        const csvRows = ['"Key","Value"'];
        
        // 各設定項目をCSV形式に変換
        for (const key in settings) {
            let value = settings[key];
            // 改行コードを\\nにエスケープし、ダブルクォートを""にエスケープ
            if (typeof value === 'string') {
                value = value.replace(/\n/g, '\\n').replace(/"/g, '""');
            }
            csvRows.push(`"${key}","${value}"`);
        }

        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'ai_settings_backup.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        alert('設定をCSVファイルとして保存しました。');
    }

    function importSettingsFromCsv(event) {
        const file = event.target.files;
        if (!file || file.length === 0) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const csvContent = e.target.result;
            try {
                const lines = csvContent.split('\n');
                if (lines.length < 2) throw new Error("CSVファイルの内容が不正です。");

                const settings = {};
                // ヘッダー行をスキップ
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line.trim()) continue;

                    // CSVのパース (単純なパースなので、複雑なCSVには対応しない可能性あり)
                    // 正規表現で安全に分割するように修正
                    const parts = line.match(/(?:[^",]|\"(?:[^"]|\"\")*\")+/g);

                    if (!parts || parts.length !== 2) { 
                        console.warn(`行 ${i+1} のパースに失敗しました: ${line}`);
                        continue;
                    }

                    // ダブルクォートを外し、エスケープを元に戻す
                    let key = parts[0].replace(/^"|"$/g, '').replace(/""/g, '"'); 
                    let value = parts[1].replace(/^"|"$/g, '').replace(/\\n/g, '\n').replace(/""/g, '"'); 
                    
                    settings[key] = value;
                }

                // 設定を適用
                personaTextarea.value = settings.persona || '';
                autoResponsePromptTextarea.value = settings.autoResponsePrompt || '時間になりました。自然な会話の流れで、何か新しい話題を提供したり、私に質問をしてみてください。';
                summaryPromptTextarea.value = settings.summaryPrompt || ''; // ★追加: 概要生成プロンプト
                userNameInput.value = settings.userName || '';
                aiNameInput.value = settings.aiName || '';
                soundOnOff.checked = settings.soundEnabled === 'true' || settings.soundEnabled === true; // "true"文字列も考慮
                soundTypeSelect.value = settings.soundType || 'sine';

                // 読み込んだ設定をローカルストレージにも保存
                saveSettingsToLocalStorage();

                alert('設定をCSVファイルから読み込みました。');
                // ファイル選択をリセット
                event.target.value = ''; // input.value = ''; は推奨されるリセット方法

            } catch (error) {
                console.error('CSVインポートエラー:', error);
                alert(`CSVファイルの読み込みに失敗しました: ${error.message}`);
                event.target.value = ''; // input.value = ''; は推奨されるリセット方法
            }
        };
        reader.onerror = () => {
            alert('ファイルの読み込み中にエラーが発生しました。');
            event.target.value = '';
        };
        reader.readAsText(file[0]); 
    }

    // --- 全チャット履歴のエクスポート/インポート関数 ---
    function exportAllChatSummaries() {
        const allSummaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
        if (allSummaries.length === 0) {
            alert('エクスポートするチャット履歴がありません。');
            return;
        }
        const jsonContent = JSON.stringify(allSummaries, null, 2); // 読みやすいように整形してJSON化
        const today = new Date();
        const formattedDate = `${today.getFullYear()}${('0' + (today.getMonth() + 1)).slice(-2)}${('0' + today.getDate()).slice(-2)}`;
        const filename = `my_chat_history_backup_${formattedDate}.json`;
        downloadMarkdown(jsonContent, filename);
        alert('全チャット履歴をJSONファイルとして保存しました。');
    }

    function importAllChatSummaries(event) {
        const file = event.target.files;
        if (!file || file.length === 0) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedSummaries = JSON.parse(e.target.result);
                if (!Array.isArray(importedSummaries)) {
                    throw new Error("インポートされたファイル形式が不正です。");
                }

                if (confirm('既存のチャット履歴にインポートした履歴を追加しますか？（「キャンセル」を選択すると既存の履歴は全て上書きされます）')) {
                    // マージ処理
                    let existingSummaries = JSON.parse(localStorage.getItem('chatSummaries') || '[]');
                    const mergedSummaries = [...existingSummaries];

                    importedSummaries.forEach(importedSummary => {
                        // ファイル名で重複チェック（ファイル名が一意である前提）
                        const existingIndex = mergedSummaries.findIndex(
                            s => s.filename === importedSummary.filename
                        );
                        if (existingIndex > -1) {
                            mergedSummaries[existingIndex] = importedSummary; // 同じファイル名があれば更新
                        } else {
                            mergedSummaries.push(importedSummary); // なければ追加
                        }
                    });
                    localStorage.setItem('chatSummaries', JSON.stringify(mergedSummaries));
                    alert('チャット履歴をマージしました。');

                } else {
                    // 上書き処理
                    localStorage.setItem('chatSummaries', JSON.stringify(importedSummaries));
                    alert('チャット履歴を上書きしました。');
                }
                
                // 現在のチャットボックスをクリアし、新しいチャットを開始
                startNewChat(true); 
                // 履歴リストを更新
                displayChatHistoryList(chatHistorySearchInput.value, currentSortBy, currentSortOrder);

            } catch (error) {
                console.error('全チャット履歴のインポートエラー:', error);
                alert(`全チャット履歴のインポートに失敗しました: ${error.message}`);
            } finally {
                event.target.value = ''; // ファイル選択をリセット
            }
        };
        reader.onerror = () => {
            alert('ファイルの読み込み中にエラーが発生しました。');
            event.target.value = '';
        };
        reader.readAsText(file[0]);
    }

    // --- ローカルストレージへの保存/読込関数 ---
    function saveSettingsToLocalStorage() {
        localStorage.setItem('geminiPersona', personaTextarea.value.trim());
        localStorage.setItem('autoResponsePrompt', autoResponsePromptTextarea.value.trim());
        localStorage.setItem('summaryPrompt', summaryPromptTextarea.value.trim()); // ★追加: 概要生成プロンプト
        localStorage.setItem('userName', userNameInput.value.trim());
        localStorage.setItem('aiName', aiNameInput.value.trim());
        localStorage.setItem('soundEnabled', soundOnOff.checked);
        localStorage.setItem('soundType', soundTypeSelect.value);
    }

    function loadSettingsFromLocalStorage() {
        personaTextarea.value = localStorage.getItem('geminiPersona') || '';
        autoResponsePromptTextarea.value = localStorage.getItem('autoResponsePrompt') || '時間になりました。自然な会話の流れで、何か新しい話題を提供したり、私に質問をしてみてください。';
        // ★追加: 概要生成プロンプトのデフォルト値
        summaryPromptTextarea.value = localStorage.getItem('summaryPrompt') || 
            `以下の会話履歴を基に、簡潔なタイトル（30文字程度）と、会話の要約を箇条書きにして作成し、JSON形式で出力してください。\n\n出力は以下のJSONフォーマットに従ってください。\n{\n  "title": "ここにタイトルを記述 (15文字程度)",\n  "summary": "ここに会話の要約を記述 (第三者の視点から自然な文章で)"\n}\n\n---\n[会話履歴]\n{CONVERSATION_HISTORY}\n---`;
        userNameInput.value = localStorage.getItem('userName') || '';
        aiNameInput.value = localStorage.getItem('aiName') || '';
        soundOnOff.checked = localStorage.getItem('soundEnabled') !== 'false';
        soundTypeSelect.value = localStorage.getItem('soundType') || 'sine';
    }

    // --- ユーティリティ関数 ---
    function playNotificationSound(soundType = 'sine') {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
            oscillator.type = soundType;
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            let frequency = 440;
            switch(soundType) {
                case 'square':   frequency = 660; break;
                case 'sawtooth': frequency = 220; break;
                case 'triangle': frequency = 523; break;
            }
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.start(); oscillator.stop(audioContext.currentTime + 0.1);
        } catch (e) { console.error("サウンドの再生に失敗しました:", e); }
    }
    function updateCurrentDateTime() {
        const now = new Date();
        const year = now.getFullYear(); const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const week = ['日','月','火','水','木','金','土'][now.getDay()];
        const reiwaYear = year - 2018;
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        datetimeDisplay.textContent = `${year}年${month}月${day}日(${week})　令和${reiwaYear}年　${hours}時${minutes}分`;
    }
    function checkApiKey() {
        if (!apiKey) {
            alert('「API設定」ボタンからAPIキーを設定してください。');
            settingsModal.style.display = 'block';
            return false;
        }
        return true;
    }
    function downloadMarkdown(content, filename) {
        const blob = new Blob([content], { type: 'text/markdown;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob); link.download = filename;
        document.body.appendChild(link); link.click();
        document.body.removeChild(link); URL.revokeObjectURL(link.href);
    }
    
    // YYYY-MM-DD 形式の文字列を返す (ファイル名など、時刻が不要な場合に使用)
    function toDateString(date) { return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; }
    // YYYY/MM/DD HH:MM 形式の文字列を返す (時刻表示に使用)
    function formatTimestamp(date) { return `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`; }

    function showHelp() {
        const helpContent = `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><title>Ｍｙチャット履歴 - 取扱説明書</title><style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif;line-height:1.7;margin:0;padding:25px;color:#333;background-color:#f9f9f9}.container{max-width:800px;margin:0 auto;background-color:#fff;padding:20px 30px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,.08)}h1{color:#2e8b57;border-bottom:3px solid #66cdaa;padding-bottom:10px;font-size:1.8em}h2{color:#3cb371;border-bottom:2px solid #e0f2f1;padding-bottom:8px;margin-top:30px;font-size:1.5em}h3{color:#2e8b57;border-left:5px solid #66cdaa;padding-left:10px;font-size:1.2em}ul{list-style-type:none;padding-left:0}li{margin-bottom:15px;padding-left:20px;position:relative}li::before{content:'✓';color:#3cb371;position:absolute;left:0;font-weight:bold}p{text-align:justify}code{background-color:#eef;color:#d63384;padding:2px 6px;border-radius:4px;font-family:'Courier New',Courier,monospace}.icon{display:inline-block;width:24px;height:24px;line-height:24px;text-align:center;border-radius:50%;color:#fff;font-size:1.1em;vertical-align:middle;margin-right:5px}.save-icon{background-color:#3cb371}.important{background-color:#fffbe6;border:1px solid #ffeeba;border-left:5px solid #ffc107;padding:15px 20px;margin:20px 0;border-radius:5px}.important strong{color:#856404}.button-desc{font-weight:bold}</style></head><body><div class="container"><h1>Ｍｙチャット履歴 - 取扱説明書</h1><p>このアプリケーションは、AIとの自由な対話を記録し、要約を生成して履歴として保存・管理できるツールです。</p><div class="important"><p><strong>【重要】</strong> 初めてご利用になる際は、必ず右上の「<b>API設定</b>」ボタンからご自身のGemini APIキーを設定してください。</p></div><h2>主な機能</h2><h3>1. AIとのチャット</h3><ul><li><span class="button-desc">メッセージの送信:</span> <code>Enter</code>キーで送信、<code>Shift + Enter</code>で改行できます。</li><li><span class="button-desc">画像の添付:</span> クリップボタン<code>📎</code>か、入力欄へのペーストで画像を添付できます。</li><li><span class="button-desc">音声入力:</span> マイクボタン<code>🎤</code>でチャット内容の音声入力が可能です。</li><li><span class="button-desc">絵文字入力:</span> 入力欄上部の絵文字ボタンで、感情表現の絵文字を簡単に入力できます。</li><li><span class="button-desc">メッセージの削除:</span> 各メッセージをクリックで選択し、ヘッダーの「<b>選択を削除</b>」で削除できます。</li><li><span class="button-desc">メッセージの編集:</span> 各メッセージをクリックで選択し、ヘッダーの「<b>選択を編集</b>」で編集できます。</li></ul><h3>2. チャットの保存と履歴管理</h3><ul><li><span class="icon save-icon">✈️</span> <span class="button-desc">チャット保存:</span> 現在の会話内容をAIが分析し、タイトルと概要を生成してマークダウン形式で保存します。同時にダウンロードも行われます。</li><li><span class="button-desc">履歴一覧:</span> ヘッダーの「<b>履歴一覧</b>」ボタンで、保存されたチャット履歴のリストを表示し、過去のチャットを呼び出すことができます。</li><li><span class="button-desc">新しいチャット:</span> 現在の会話を破棄して、新しいチャットを開始します。</li></ul><h3>3. 各パネルの機能</h3><ul><li><span class="button-desc">自動応答タイマー:</span> 設定した時間ごとにAIが自動で話しかけてくれます。</li></ul><h3>4. ヘッダーの各種ボタン</h3><ul><li><span class="button-desc">各種設定:</span> AIの性格、チャット概要生成プロンプト、あなたとAIの名前などを設定できます。<b>「設定をCSVで保存」/「設定をCSVから読込」で設定のバックアップ・復元も可能です。</b></li><li><span class="button-desc">API設定:</b> Gemini APIキーを設定・テスト・削除できます。</li><li><span class="button-desc">PDFプレビュー:</b> 現在のチャット内容をPDF形式でプレビュー表示・ダウンロードできます。</li></ul><h2>注意事項</h2><ul><li>APIキー、会話履歴、チャット履歴、各種設定は、すべてお使いのブラウザのローカルストレージに保存されます。<b>サーバーには一切データは送信・保存されません。</b></li><li>ブラウザのキャッシュや履歴を消去すると、保存したデータがすべて失われる可能性がありますのでご注意ください。</li><li>Gemini APIの利用料金は、APIキーを発行したご自身のGoogleアカウントに準じます。利用量にご注意ください。</li></ul></div></body></html>`;
        const helpWindow = window.open('', '_blank');
        helpWindow.document.write(helpContent);
        helpWindow.document.close();
    }

    // --- メッセージ削除・編集関連の関数 ---
    function updateDeleteButtonVisibility() {
        const selectedMessages = document.querySelectorAll('.message.selected');
        deleteSelectedButton.style.display = selectedMessages.length > 0 ? 'block' : 'none';
        editSelectedButton.style.display = selectedMessages.length === 1 ? 'block' : 'none'; // 編集ボタンは1つだけ選択されている場合に表示
    }
    function deleteSelectedMessages() {
        const selectedMessages = document.querySelectorAll('.message.selected');
        if (selectedMessages.length === 0) { alert('削除するメッセージが選択されていません。'); return; }
        if (confirm(`選択した ${selectedMessages.length} 件のメッセージを削除しますか？`)) {
            const idsToDelete = new Set();
            selectedMessages.forEach(msg => {
                idsToDelete.add(msg.dataset.id);
                msg.remove();
            });
            conversationHistory = conversationHistory.filter(item => !idsToDelete.has(String(new Date(item.timestamp).getTime())));
            saveChatHistory();
            updateDeleteButtonVisibility();
        }
    }

    // メッセージ編集モーダルを開く
    function openEditMessageModal() {
        const selectedMessage = document.querySelector('.message.selected');
        if (!selectedMessage) return;

        editingMessageElement = selectedMessage; // 編集対象のメッセージ要素を保存
        const messageText = selectedMessage.querySelector('div:not(.timestamp):not(.message-image)')?.textContent || ''; // 画像やタイムスタンプ以外のテキストを取得

        editMessageTextarea.value = messageText;
        editMessageModal.style.display = 'block';
    }

    // 編集されたメッセージを保存する
    saveEditedMessageButton.addEventListener('click', () => {
        if (!editingMessageElement) return;

        const newText = editMessageTextarea.value;
        const messageId = editingMessageElement.dataset.id;

        // DOM上のテキストを更新
        const textElement = editingMessageElement.querySelector('div:not(.timestamp):not(.message-image)');
        if (textElement) {
            // URLを検出し、不要な前後の記号（[]や()）を除去してリンク化する正規表現
            const urlRegex = /(?:^|(?<=\s))\[?(https?:\/\/[^\s]+?)(?:\]|\)|\.)?(?=\s|$)/g;

            let processedText = newText.replace(/\n/g, '<br>');
            processedText = processedText.replace(urlRegex, (match, url) => {
                let cleanUrl = url.replace(/^[.,!?:;\]\)]+|[.,!?:;\]\)]+$/g, '');
                return `<a href="${cleanUrl}" target="_blank">${cleanUrl}</a>`;
            });
            textElement.innerHTML = processedText;
        } else if (!editingMessageElement.querySelector('.message-image')) {
             // テキスト要素がない場合（画像のみなど）、新規にテキスト要素を作成
             const newTextElement = document.createElement('div');
             const urlRegex = /(?:^|(?<=\s))\[?(https?:\/\/[^\s]+?)(?:\]|\)|\.)?(?=\s|$)/g;
             let processedText = newText.replace(/\n/g, '<br>');
             processedText = processedText.replace(urlRegex, (match, url) => {
                 let cleanUrl = url.replace(/^[.,!?:;\]\)]+|[.,!?:;\]\)]+$/g, '');
                 return `<a href="${cleanUrl}" target="_blank">${cleanUrl}</a>`;
             });
             newTextElement.innerHTML = processedText;
             editingMessageElement.prepend(newTextElement); // メッセージの先頭に追加
        }


        // conversationHistoryの該当メッセージを更新
        const messageIndex = conversationHistory.findIndex(item => String(new Date(item.timestamp).getTime()) === messageId);
        if (messageIndex !== -1) {
            conversationHistory[messageIndex].content = newText;
            saveChatHistory();
        }

        editingMessageElement.classList.remove('selected'); // 選択状態を解除
        editingMessageElement = null; // 編集中のメッセージ要素をクリア
        editMessageModal.style.display = 'none';
        updateDeleteButtonVisibility(); // ボタンの表示状態を更新
    });

    closeEditMessageModal.addEventListener('click', () => {
        editingMessageElement = null; // 編集対象をクリア
        editMessageModal.style.display = 'none';
    });
</script>

</body>
</html>